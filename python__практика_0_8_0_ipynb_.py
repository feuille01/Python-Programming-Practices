# -*- coding: utf-8 -*-
"""Python  "Практика 0.8.0.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15tb9u6HJl8T6JKXLRq6oQzTr5r9kPRfJ

# Задание 1

Задача: Создать чат бота для получения информации об исследованиях космоса

Описание: Создайте комплексное приложение командной строки, которое будет использоваться в качестве панели управления исследованиями космоса. Данное приложение будет обращаться к https://api.nasa.gov/ для предоставления пользователям набора информации о космосе, включая:

- Астрономическая картинка дня (APOD): Отображение APOD с пояснениями к нему.
- Фотографии с марсохода: позволяет пользователям выбирать и фильтровать фотографии с марсохода по дате и типу камеры.
- Объекты, сближающиеся с Землей (ОСЗ): Поиск и отображение информации об объекте, сближающихся с Землей, на определенную дату, включая их размеры и потенциальную опасность.
- Данные о космической погоде: Отображают последние данные о космической погоде, включая солнечные вспышки и геомагнитные бури.
Приложение должно позволять пользователям ориентироваться в этих функциях, корректно обрабатывать ошибки и обеспечивать удобство работы.

Требования:
- Пользовательский ввод: Приложение должно предложить пользователю ввести данные, чтобы выбрать, какую функцию он хочет изучить.
- Проверка данных: Убедитесь, что пользовательские данные (например, даты) проверены.
- Обработка ошибок: Корректно обрабатывайте ошибки API и неверные ответы.
- Представление данных: Представляйте данные в четкой и организованной форме.
- Опция выхода: позволяет пользователям выходить из приложения в любое время.
"""

import requests
import datetime

NASA_URL = "https://api.nasa.gov"
API_KEY = "wUBA7yd1WemdjNVHWy0WWWwwWEy61KjFjusAbfve"


# Функция для получения астрономической картинки дня (APOD)
def get_apod():
    url = f"{NASA_URL}/planetary/apod?api_key={API_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        print(f"\n*** Астрономическая картинка дня ***")
        print(f"Дата: {data.get('date')}")
        print(f"Название: {data.get('title')}")
        print(f"Описание: {data.get('explanation')}")
        print(f"URL: {data.get('url')}")
    else:
        print("Ошибка получения APOD")


# Функция для получения фотографий с марсохода
def get_mars_photos():
    rover = input("Введите название марсохода (Curiosity, Opportunity, Spirit): ").capitalize()
    date = input("Введите дату в формате ГГГГ-ММ-ДД: ")
    camera = input("Введите тип камеры (FHAZ, RHAZ, MAST и т.д. или оставьте пустым): ").upper()

    url = f"{NASA_URL}/mars-photos/api/v1/rovers/{rover}/photos?earth_date={date}&api_key={API_KEY}"
    if camera:
        url += f"&camera={camera}"
    response = requests.get(url)
    if response.status_code == 200:
        photos = response.json().get("photos", [])
        if photos:
            print(f"\n    Найдено {len(photos)} фотографий    ")
            for photo in photos[:5]:
                print(f"Камера: {photo['camera']['full_name']}")
                print(f"URL: {photo['img_src']}")
                print("-" * 50)
        else:
            print("Фотографии не найдены на указанную дату.")
    else:
        print(f"Ошибка получения фотографий")


# Функция для получения объектов, сближающихся с Землей (ОСЗ)
def get_neos():
    date = input("Введите дату в формате ГГГГ-ММ-ДД: ")

    url = f"{NASA_URL}/neo/rest/v1/feed?start_date={date}&end_date={date}&api_key={API_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        neos = data.get("near_earth_objects", {}).get(date, [])
        if neos:
            print(f"\nНайдено {len(neos)} объектов, сближающихся с Землей ")
            for neo in neos[:5]:  # Ограничим вывод первыми 5 объектами
                print(f"Название: {neo['name']}")
                print(f"Диаметр: {neo['estimated_diameter']['meters']['estimated_diameter_max']} м")
                if neo['is_potentially_hazardous_asteroid']:
                    print("Потенциально опасен")
                else:
                    print("Не опасен")
                print("-" * 50)
        else:
            print("Объекты не найдены на указанную дату.")
    else:
        print(f"Ошибка получения данных об ОСЗ")


# Функция для получения данных о космической погоде
def get_space_weather():
    url = f"{NASA_URL}/DONKI/FLR?startDate={datetime.date.today()}&api_key={API_KEY}"
    response = requests.get(url)
    if response.status_code == 200:
        flares = response.json()
        if flares:
            print(f"\nНайдены {len(flares)} события солнечных вспышек")
            for flare in flares[:5]:  # Ограничим вывод первыми 5 событиями
                print(f"Событие: {flare['flrID']}")
                print(f"Начало: {flare['beginTime']}")
                print(f"Влияние: {flare.get('impact')}")
                print("-" * 50)
        else:
            print("Данные о солнечных вспышках не найдены.")
    else:
        print(f"Ошибка получения данных о космической погоде: {response.status_code}")


# Основная функция
def main():
    while True:
        print("\n*** Меню управления по просмотру исследований космоса ***")
        print("1. Астрономическая картинка дня (APOD)")
        print("2. Фотографии с марсохода")
        print("3. Объекты, сближающиеся с Землей (ОСЗ)")
        print("4. Данные о космической погоде")
        print("5. Выход")

        choice = input("Выберите опцию (1-5): ")
        if choice == "1":
            get_apod()
        elif choice == "2":
            get_mars_photos()
        elif choice == "3":
            get_neos()
        elif choice == "4":
            get_space_weather()
        elif choice == "5":
            print("Выход из программы. До свидания!")
            break
        else:
            print("Некорректный выбор. Пожалуйста, попробуйте снова.")


main()

"""# Задание 2

Описание задачи

Цель этой задачи - создать скрипт на Python, который взаимодействует с API Чикагского института искусств (https://api.artic.edu/docs/) для извлечения и отображения произведений искусства. Скрипт должен позволять пользователям просматривать работы по страницам, фильтровать их по имени художника и просматривать подробную информацию о выбранных произведениях искусства. Ниже приведены требования и функциональные возможности, которые необходимо реализовать:

Требования:
Извлекать произведения искусства:

- Создайте функцию, которая извлекает список произведений искусства из API Чикагского института искусств.
Функция должна принимать параметр page для разбивки на страницы и возвращать список произведений искусства вместе с информацией о разбивке на страницы.
Фильтровать произведения искусства:

- Реализуйте функцию, которая фильтрует список произведений искусства на основе имени указанного художника. Функция должна возвращать список работ, которые соответствуют имени художника (без учета регистра).
Отображать подробную информацию об оформлении:

- Напишите функцию, которая отображает названия работ для пользователя и позволяет ему выбрать одну из них, введя соответствующий номер.
После выбора функция должна отображать подробную информацию о выбранном произведении, включая название, исполнителя, дату и носитель.
Разбивка на страницы и взаимодействие с пользователем:

- Создайте основную функцию, которая управляет выборкой произведений и взаимодействием с пользователем.

Разрешите пользователям перемещаться по страницам с произведениями искусства, выполнять фильтрацию по исполнителю или выходить из программы.

Если страниц с произведениями искусства несколько, укажите варианты перехода к следующей странице, предыдущей странице, фильтрации по исполнителю или выхода из программы.
"""

import requests


# Функция извлечения списка произведений искусства
def selection_artworks(page=1):
    url = f"https://api.artic.edu/api/v1/artworks?page={page}&limit=10"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        return {
            "artworks": data["data"],
            "pagination": data["pagination"]
        }
    else:
        print("Ошибка при запросе данных:", response.status_code)
        return None


# Функция фильтрации по художнику
def filter_by_artist(artworks, artist_name):
    artist_name = artist_name.lower()
    return [
        artwork for artwork in artworks
        if artist_name in (artwork.get("artist_title") or "").lower()
    ]


# Функция отображения подробной информации о произведении искусства
def display_artwork_details(artworks):
    for id_elem, artwork in enumerate(artworks, start=1):
        print(f"{id_elem}. {artwork.get('title', 'Без названия')}")

    try:
        choice = int(input("\nВыберите номер произведения для просмотра деталей (0 для выхода): "))
        if 0 < choice <= len(artworks):
            artwork = artworks[choice - 1]
            print(f"Название: {artwork.get('title', 'Неизвестно')}")
            print(f"Художник: {artwork.get('artist_title', 'Неизвестно')}")
            print(f"Дата: {artwork.get('date_display', 'Не указана')}")
            print(f"Носитель: {artwork.get('medium_display', 'Не указан')}")
        elif choice == 0:
            print("Возврат в главное меню.")
        else:
            print("Неверный выбор.")
    except ValueError:
        print("Пожалуйста, введите допустимый номер.")


# Главная функция
def main():
    page = 1
    while True:
        print(f"\nВыполняется запрос страницы {page}...")
        data = selection_artworks(page)

        if data is None:
            break

        artworks = data["artworks"]
        pagination = data["pagination"]

        print("\nПроизведения на текущей странице:")
        display_artwork_details(artworks)

        print("\nОпции:")
        print("1. Следующая страница")
        print("2. Предыдущая страница")
        print("3. Фильтровать по имени художника")
        print("4. Выйти")

        choice = input("Введите номер действия: ")
        if choice == "1":
            if page < pagination["total_pages"]:
                page += 1
            else:
                print("Вы на последней странице.")
        elif choice == "2":
            if page > 1:
                page -= 1
            else:
                print("Вы на первой странице.")
        elif choice == "3":
            artist_name = input("Введите имя художника: ")
            filtered_artworks = filter_by_artist(artworks, artist_name)
            if filtered_artworks:
                print(f"\nРаботы художника {artist_name}:")
                display_artwork_details(filtered_artworks)
            else:
                print(f"Работ художника с именем '{artist_name}' не найдено.")
        elif choice == "4":
            print("Выход из программы.")
            break
        else:
            print("Неверный выбор. Попробуйте снова.")


main()

"""# Задание 3

Задача: Создать программу по управлению портфелем криптовалют

Цель: Создать скрипт на Python, который извлекает цены на криптовалюты в режиме реального времени, позволяет пользователям управлять портфелем криптовалют, вычисляет общую стоимость портфеля, отслеживает изменения цен и предоставляет исторические данные о ценах для анализа.

Требования:
Получение текущих цен на криптовалюты:

Используйте https://docs.coingecko.com/ для получения актуальных цен на список криптовалют.

Управление портфелем:

- Позволяет пользователю создавать портфель криптовалют и управлять им, указывая количество каждой криптовалюты, которой он владеет.
- Расчитывает общую стоимость портфеля в указанной фиатной валюте (например, долларах США).

Отслеживание изменения цен:

- Отображение процентного изменения цены для каждой криптовалюты в портфеле за последние 24 часа.
- Выделите все криптовалюты, стоимость которых значительно увеличилась или снизилась.

Поиск исторических данных о ценах:

- Получение исторических данных о ценах на указанную криптовалюту за последнюю неделю.
- Предоставьте пользователю возможность визуализировать эти данные в простом текстовом формате (например, цены за день).

Взаимодействие с пользователем:

- Реализуйте интерфейс командной строки для ввода данных пользователем.
- Предоставьте опции для получения текущих цен, управления портфелем, просмотра изменений цен или анализа исторических данных.
"""

import requests
import datetime


# Функция для получения актуальных цен на криптовалюты
def get_current_prices(crypto_ids, currency='usd'):
    url = f"https://api.coingecko.com/api/v3/simple/price?ids={','.join(crypto_ids)}&vs_currencies={currency}&include_24hr_change=true"
    response = requests.get(url)
    data = response.json()
    return data


# Функция для получения исторических данных (цены за последние 7 дней)
def get_historical_data(crypto_id, currency='usd'):
    end_date = datetime.datetime.now()
    start_date = end_date - datetime.timedelta(days=7)
    url = f"https://api.coingecko.com/api/v3/coins/{crypto_id}/market_chart?vs_currency={currency}&days=7"
    response = requests.get(url)
    data = response.json()
    return data['prices']  # Список цен за 7 дней


# Функция для вычисления общей стоимости портфеля
def calculate_portfolio_value(portfolio, prices):
    total_value = 0
    for crypto, amount in portfolio.items():
        if crypto in prices:
            total_value += prices[crypto]['usd'] * amount
    return total_value


# Функция для отображения информации о изменениях цен за 24 часа
def display_price_changes(prices):
    for crypto, price_data in prices.items():
        change_24h = price_data.get('usd_24h_change', 0)
        print(f"{crypto}: {change_24h:.2f}% изменения за 24 часа")


# Функция для отображения исторических данных
def display_historical_data(crypto_id, historical_data):
    print(f"История цен для {crypto_id}:")
    for timestamp, price in historical_data:
        date = datetime.datetime.fromtimestamp(timestamp / 1000).strftime('%Y-%m-%d')
        print(f"{date}: {price}")


# Основной интерфейс программы
def main():
    print("Программа по управлению портфелем криптовалют")
    portfolio = {}

    while True:
        print("\nОпции:")
        print("1. Добавить криптовалюту в портфель")
        print("2. Оценка стоимости портфеля")
        print("3. Просмотр изменения цен на криптовалюты в портфеле")
        print("4. Просмотр исторических данных по криптовалюте")
        print("5. Выход")

        choice = input("Введите номер действия: ")

        if choice == '1':
            crypto = input("Введите название криптовалюты (например: bitcoin, ethereum): ").lower()
            amount = float(input("Введите количество криптовалюты: "))
            portfolio[crypto] = amount
            print(f"Добавлено {amount} {crypto} в ваш портфель.")

        elif choice == '2':
            crypto_ids = list(portfolio.keys())
            prices = get_current_prices(crypto_ids)
            total_value = calculate_portfolio_value(portfolio, prices)
            print(f"Общая стоимость портфеля: ${total_value:.2f}")

        elif choice == '3':
            crypto_ids = list(portfolio.keys())
            prices = get_current_prices(crypto_ids)
            display_price_changes(prices)

        elif choice == '4':
            crypto_id = input("Введите название криптовалюты для просмотра истории изменения (например: bitcoin, ethereum): ").lower()
            historical_data = get_historical_data(crypto_id)
            display_historical_data(crypto_id, historical_data)

        elif choice == '5':
            print("Выход...")
            break

        else:
            print("Неправильный номер действия. Попробуйте снова.")


main()

"""# Дополнительно: Задание 4

Задание 4: Проектное

Вам необходимо самостоятельно найти откртое API предоставляющее информацию в открытом доступе и реализовать собственный проект!


Критерии приемки результата:

- Проект включает в себя не менее 5 возможостей для пользователя
- Проект позволяет использовать все возможности проекта пользователю при помощи взаимодействия через коммандную строку
- Проект работает с открытым API (это значит что при проверке вашей работы преподавателем, преподавателю необходимо просто запустить ячейку с кодом вашего проекта и она будет работать без дополнительных манипуляции)
- Проект должен обязательно включать в себя ряд используемых конструкции:
    - Функции
    - Условные конструкции
    - Ввод/вывод
    - Словари/Списки
- Допускается использование библиотек:
    - requests
    - datetime
    - random

**Здесь добавьте описание вашего проекта**
"""

#  А здесь код